# -*- coding: utf-8 -*-
"""LQR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1foIaoPa51ZtFFBxGyAFi2kROUldMwvJI
"""

!sudo apt install libslicot-dev

# implementation of LQR at the upward equilibrium
from Models import PendulumOnCart
from casadi import *
import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import expm as scipy_expm


class LQR:
  def __init__(self, sys = PendulumOnCart().model(),
              lin_state_pt = np.array([0, 0, 0, 0]),
               lin_control_pt = np.array([0]),
               t0 = 0,
               tf = 2,
               N = 250,
               Q = np.diag([1, 1, 1, 1]) * 10,
               R = np.diag([1]) * 1,
               Qf = np.diag([1, 1, 1, 1]) * 2000,
               ):
    self.sys = sys
    self.lin_state_pt = DM(lin_state_pt)
    self.lin_control_pt = DM(lin_control_pt)
    self.t0 = t0
    self.tf = tf
    self.N = N
    self.Q = Q
    self.R = R
    self.Qf = Qf

    # here first linearize and then discretize
    # 1. linearization
    self.states = self.sys['x']
    self.control = self.sys['p']
    self.dynamics = self.sys['ode']
    self.A = Function('A', [self.states, self.control], [jacobian(self.dynamics, self.states)])
    self.B = Function('B', [self.states, self.control], [jacobian(self.dynamics, self.control)])
    self.A = self.A(self.lin_state_pt, self.lin_control_pt).full()
    self.B = self.B(self.lin_state_pt, self.lin_control_pt).full()
    cont_ctrb = np.concatenate((self.B, self.A @ self.B,
                                self.A @ self.A @ self.B,
                                self.A @ self.A @ self.A @ self.B), axis = 1)
    print("rank of continuous controllability matrix : ", np.linalg.matrix_rank(cont_ctrb))

    # 2. using approximate discretization by Rk4 method
    self.dt = (self.tf - self.t0) / self.N
    # Identity matrix
    I = np.eye(4)
    # Compute k1, k2, k3, k4
    k1 = self.A
    k2 = self.A + (self.dt / 2) * k1
    k3 = self.A + (self.dt / 2) * k2
    k4 = self.A + self.dt * k3
    # Compute Ad and Bd using RK4 formula
    self.Ad = I + (self.dt / 6) * (k1 + 2 * k2 + 2 * k3 + k4)
    self.Bd = self.dt * self.B

    # checking the controllability condition
    ctrb = np.concatenate((self.Bd, self.Ad @ self.Bd,
                           self.Ad @ self.Ad @ self.Bd,
                           self.Ad @ self.Ad @ self.Ad @ self.Bd), axis = 1)
    print("Rank of discrete controllability matrix : ", np.linalg.matrix_rank(ctrb))

  def solve_riccati(self):
    """
    Solving matrix difference riccati equation
    """
    P_N = self.Qf
    Pk1 = P_N
    self.controllers = []
    for i in range(self.N - 1, -1, -1):
      Pk = self.Q + self.Ad.T @ Pk1 @ self.Ad \
      - self.Ad.T @ Pk1 @ self.Bd @ np.linalg.pinv(self.R + self.Bd.T @ Pk1 @ self.Bd)\
      @ self.Bd.T @ Pk1 @ self.Ad
      Kk = np.linalg.pinv(self.R + self.Bd.T @ Pk1 @ self.Bd) @ self.Bd.T @ Pk1 @ self.Ad
      Pk1 = Pk
      if np.linalg.det(Pk) < 0:
        print("negative determinant")

      self.controllers.append(Kk)
    self.controllers.reverse()
    return self.controllers


  def simulation(self, x0 = np.array([0, 0.1, 0, 0])):
    """
    simulate the response of controllers for given inital conditions
    """
    sys = integrator('system', 'cvodes', self.sys, 0, self.dt)
    states = np.zeros((self.N, 4))
    states[0, :] = x0
    for i in range(self.N - 1):
      ut = -self.controllers[i] @ states[i, :]
      states[i + 1, :] = sys(x0 = DM(states[i, :]), p = DM(ut))['xf'].full().reshape(1, 4)
    # plt.plot(states[:, 1], states[:, 3])
    # plt.show()

    plt.figure()
    plt.plot(states[:, 0], label = 'lin pos')
    plt.plot(states[:, 1], label = 'ang pos')
    plt.plot(states[:, 2], label = 'lin acc')
    plt.plot(states[:, 3], label = 'ang acc')
    plt.legend()
    plt.grid()
    plt.show()
    return None

obj = LQR(Q = np.diag([1, 1, 1, 1]) * 10,
          R = np.diag([1]) * 1,
          Qf = np.diag([1, 1, 1, 1]) * 2000,
          tf = 3)
temp = obj.solve_riccati()
obj.simulation()

A = np.array([[1, 2, 3], [1, 2, 3], [1, 2 ,3]])
print(A @ A @ A)
print(A ** 3)