# -*- coding: utf-8 -*-
"""trajectory_stabilization.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QUHPzzBHkaeLcUR9amcTch9j5BiE2iXG
"""

!pip install casadi

from casadi import *
import numpy as np
import matplotlib.pyplot as plt
from Models import PendulumOnCart
import joblib

data = joblib.load('data_1.pkl')
x_nominal = data['x_opt']
u_nominal = data['u_opt']
print(u_nominal.shape)
# implementation of trajectory stabalization using LQR for LTV system approach
class LQTT:
  def __init__(self, sys = PendulumOnCart().model(),
               x_nominal = x_nominal,
               u_nominal = u_nominal,
               t0 = 0,
               tf = 2,
               N = 250,
               Q = np.eye(4) * 20,
               Qf = np.eye(4) * 100,
               R = np.eye(1) * 1,
               m = 1,
               n = 4
               ):
    self.sys = sys
    self.x_nominal = x_nominal
    self.u_nominal = u_nominal
    self.t0 = t0
    self.tf = tf
    self.N = N
    self.dt = (self.tf - self.t0) / self.N
    self.Q = Q
    self.Qf = Qf
    self.R = R
    self.m = m
    self.n = n
    self.As = np.zeros((N, n, n))
    self.Bs = np.zeros((N, n, m))

    # linearize the system on the nominal trajectory
    self.states = sys['x']
    self.control = sys['p']
    self.dynamics = sys['ode']
    self.sym_A = jacobian(self.dynamics, self.states)
    self.sym_B = jacobian(self.dynamics, self.control)
    self.eval_A = Function('eval_A', [self.sys['x'], self.sys['p']], [self.sym_A])
    self.eval_B = Function('eval_B', [self.sys['x'], self.sys['p']], [self.sym_B])

    for i in range(self.N):
      x = self.x_nominal[i]
      u = self.u_nominal[i]
      A = self.eval_A(DM(x), DM(u)).full().reshape(n, n)
      B = self.eval_B(DM(x), DM(u)).full().reshape(-1, m)
      self.As[i] = A
      self.Bs[i] = B


    self.Ad = np.zeros_like(self.As)
    self.Bd = np.zeros_like(self.Bs)
    for i in range(self.N):
        self.Ad[i] = np.eye(n) + self.As[i] * self.dt + self.dt ** 2 * self.As[i] @ self.As[i]/2\
          + self.dt ** 3 * self.As[i] @ self.As[i] @ self.As[i]/6 + self.dt ** 4 * self.As[i] @ self.As[i] @ self.As[i] @ self.As[i]/24
        self.Bd[i] = self.Bs[i] * self.dt + self.dt ** 2 * self.As[i] @ self.Bs[i]/2 + self.dt ** 3 * self.As[i] @ self.As[i] @  self.Bs[i]/6\
          + self.dt ** 4 * self.As[i] @ self.As[i] @ self.As[i] @ self.Bs[i]


  def solve_riccati(self):
    """solving discrete time riccati eqation"""
    PN = self.Qf
    Pk1 = PN
    self.controllers = []
    for i in range(self.N - 1, -1, -1):
      Pk = self.Q + self.Ad[i].T @ Pk1 @ self.Ad[i] - self.Ad[i].T @ Pk1 @ self.Bd[i] \
      @ np.linalg.pinv(self.R + self.Bd[i].T @ Pk1 @ self.Bd[i]) \
      @ self.Bd[i].T @ Pk1 @ self.Ad[i]
      Kk = np.linalg.pinv(self.R + self.Bd[i].T @ Pk1 @ self.Bd[i]) @ self.Bd[i].T\
       @ Pk1 @ self.Ad[i]
      Pk1 = Pk
      if np.linalg.det(Pk1) <= 0:
        print('negative definite')

      self.controllers.append(Kk)
    self.controllers.reverse()
    return Pk


  def control_calculation(self, i, x):
    return -self.controllers[i] @ (x - self.x_nominal[i]).T + u_nominal[i]

  def simulation(self, x0 = [0, np.pi - 1, 0 , 0], plot = True):
    """simulation of the non-lienear system"""
    discrete_dynamics = integrator('discrete', 'cvodes', self.sys, 0, self.dt)
    states = np.zeros((self.N + 1, self.n))
    states[0, :] = np.array(x0)
    control = np.zeros((self.N, self.m))
    for i in range(self.N ):
      ut = self.control_calculation(i, states[i, :])
      control[i] = ut
      states[i + 1, :] = discrete_dynamics(x0 = DM(states[i, :]), p = DM(ut))['xf'].full().reshape(1, -1)
    if plot:
      plt.plot(states[:, 0], label = 'lin pos')
      plt.plot(states[:, 1], label = 'ang pos')
      plt.plot(states[:, 2], label = 'lin vel')
      plt.plot(states[:, 3], label = 'ang vel')
      plt.legend()
      plt.grid()
      plt.xlabel('time')
      plt.ylabel('states')
      plt.show()

      plt.figure()
      plt.plot(control, label = 'Traj. track control')
      plt.plot(self.u_nominal, label = 'Nominal control')
      plt.legend()
      plt.grid()
      plt.xlabel('time')
      plt.ylabel('control')
      plt.show()

    return states, control

  def generate_multiplots(self):
    """generate multiple plots of the system"""
    initial_states = np.array([
        [0, np.pi - 0.1, 0,  0],
        [0, np.pi + 0.2, 0, 1],
        [0, np.pi - 0.5, 0, -1.5],
        [0, np.pi - 1.7, 0, -0.7],
    ])
    for i in range(initial_states.shape[0]):
      states, control = self.simulation(x0 = initial_states[i, :], plot = False)
      plt.plot(states[:, 1], states[:, 3], label = f'trajectory_{i + 1}')
    plt.plot(self.x_nominal[:, 1], self.x_nominal[:, 3], label = 'nominal trajectory')
    plt.legend()
    plt.grid()
    plt.xlabel('angular position')
    plt.ylabel('angular velocity')
    plt.show()


obj = LQTT()
obj.solve_riccati()
print(obj.control_calculation(1, x = np.array([0,0,0,0])))
# obj.generate_multiplots()
_, _ = obj.simulation()