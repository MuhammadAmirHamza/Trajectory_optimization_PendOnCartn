# -*- coding: utf-8 -*-
"""Direct collocation HS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1h4RSRC1_TELijwAzKIqz6eT6keqVXsDb
"""
#%%
# Hermite Simpson Direct collocation method

import numpy as np
import matplotlib.pyplot as plt
from casadi import *
from Models import PendulumOnCart

class HermiteSimpsonDirectCollocation:
  def __init__(self, sys = PendulumOnCart().model(),
                 x0 = [0, pi, 0, 0], xf = [0,0,0,0],
                 Q = np.eye(4) * 4,
                 R = 2,
                 Qf = np.eye(4) * 20,
                 t0 = 0,
                 tf = 2,
                 N = 250,
                 ):
        self.sys = sys
        self.x0 = DM(x0)
        self.xf = DM(xf)
        self.t0 = t0
        self.tf = tf
        self.Q = Q
        self.Qf = Qf
        self.R = R
        self.N = N
        self.dt = (tf - t0) / self.N

  def optimize(self):
    x = self.sys['x']
    u = self.sys['p']
    sys_dynamics = Function('sys_dynamics', [x, u], [self.sys['ode']])
    cost = Function('system_runing_cost',  [self.sys['x'], self.sys['p']],
                        [x.T @ self.Q @ x + u.T @ self.R @ u])

    # optimization parameter
    w = []
    w0 = []
    lbw = []
    ubw = []
    J = 0
    g = []
    lbg = []
    ubg = []

    # decision variables
    n = self.sys['x'].size1()
    X = MX.sym('X', n, self.N)
    U = MX.sym('U', 1, self.N)
    X12 = MX.sym('X12', n, self.N - 1) # mid points
    U12 = MX.sym('U12', 1, self.N - 1) # mid points
    w = vertcat(X.reshape((n * self.N, 1)), X12.reshape((n * (self.N - 1), 1)),\
                U.reshape((1 * self.N, 1)), U12.reshape((1 * (self.N - 1), 1)))

    # constraints on the decision variables
    lbw += [-inf] * n * self.N + [-inf] * n * (self.N - 1)
    lbw += [-25] * 1 * self.N + [-15] * 1 * (self.N - 1)
    ubw += [inf] * n * self.N + [inf] * n * (self.N - 1)
    ubw += [25]  * 1 * self.N +  [15] * 1 * (self.N - 1)

    # boundary constraints
    g += [X[:, 0] - self.x0]
    g += [X[:, -1] - self.xf]
    lbg += [0] * n * 2
    ubg += [0] * n * 2

    # hermite-simpson dynamic constraints (seperate form)
    for i in range(self.N - 1):
      uk = U[:, i]
      uk1 = U[:, i + 1]
      uk12 = U12[:, i]
      xk = X[:, i]
      xk1 = X[:, i + 1]
      xk12 = X12[:, i]

      g += [xk1 - xk - 1/6 * self.dt * (sys_dynamics(xk,uk)\
                                        + 4 * sys_dynamics(xk12, uk12)\
                                        + sys_dynamics(xk1, uk1))]
      g += [xk12 - 1/2 * (xk + xk1) - 1/8 * self.dt * (sys_dynamics(xk, uk)\
                                                       - sys_dynamics(xk1, uk1)) ]
      lbg += [0] * n * 2
      ubg += [0] * n * 2

      # running cost
      J += self.dt/6 * (cost(xk, uk) + 4 * cost(xk12, uk12) + cost(xk1, uk1))

    # terminal cost
    x = X[:, -1]
    J += 1/2 * (x.T @ self.Qf @ x)

    # initial guess
    temp1 = []
    temp2 = []
    for i in range(n):
      temp1 += list(np.linspace(self.x0[i], self.xf[i], self.N))
      temp2 += list(np.linspace(self.x0[i], self.xf[i], self.N - 1))
      # temp1 += [self.x0[i]] * self.N
      # temp2 += [self.x0[i]] * (self.N - 1)
    w0 += temp1 + temp2
    w0 += [0] * (2 * self.N - 1)

    # nlp problem
    nlp = {'x':w, 'f':J, 'g':vertcat(*g)}
    nlp_solver = nlpsol('nlp_solver', 'ipopt', nlp)
    sol = nlp_solver(x0 = DM(w0), lbx = DM(lbw), ubx = DM(ubw), lbg = DM(lbg), ubg = DM(ubg))
    states = sol['x'].full()[: self.N * n * 2 - 1]
    self.opt_states = states[: self.N * n].reshape((n , self.N))

    controls = sol['x'].full()[-(self.N * 2 - 1) : ]
    self.opt_u = controls[: self.N]
    self.opt_u_mid = controls[-(self.N - 1):]

    self.opt_u = self.opt_u.T
    self.opt_u_mid = self.opt_u_mid.T

    return self.opt_states, self.opt_u, self.opt_u_mid

  def simulation(self, initial_cond = [0, pi - 0.1, 0, 0]):

    self.opt_u = np.concatenate((self.opt_u, np.zeros((1,1))), axis = 1)
    self.opt_u_mid = np.concatenate((self.opt_u_mid, np.zeros((1,1))), axis = 1)
    # preturbed initial state
    pos = np.zeros(self.N)
    vel = np.zeros(self.N)
    theta = np.zeros(self.N)
    theta_dot = np.zeros(self.N)
    state = DM(initial_cond)
    tn = 10
    h = self.dt
    # discretize the system
    sys_dics = integrator('disc_sys', 'cvodes', self.sys, 0, self.dt/tn)
    for i in range(self.N ):
        uk = self.opt_u[0, i]
        uk1 = self.opt_u[0, i+1]
        uk12 = self.opt_u_mid[0, i]
        for t in range(tn):
            tau = t/tn * h
            ut = 2/h**2 * (tau - h/2)*(tau - h) * uk - 4/h**2 * tau * (tau - h) * uk12\
                + 2/h**2 * tau * (tau - h/2) * uk1
            state = sys_dics(x0 = state, p = ut)['xf']
        pos[i] = float(state[0])
        theta[i] = float(state[1])
        vel[i] = float(state[2])
        theta_dot[i] = float(state[3])

    # for original initial state
    org_pos = np.zeros(self.N)
    org_vel = np.zeros(self.N)
    org_theta = np.zeros(self.N)
    org_theta_dot = np.zeros(self.N)

    inter_u = []
    state = self.x0
    # discretize the system
    for i in range(self.N ):
        uk = self.opt_u[0, i]
        uk1 = self.opt_u[0, i+1]
        uk12 = self.opt_u_mid[0, i]
        for t in range(tn):
            tau = t/tn * h
            ut = 2/h**2 * (tau - h/2)*(tau - h) * uk - 4/h**2 * tau * (tau - h) * uk12\
                + 2/h**2 * tau * (tau - h/2) * uk1
            inter_u.append(ut)
            state = sys_dics(x0 = state, p = ut)['xf']

        org_pos[i] = float(state[0])
        org_theta[i] = float(state[1])
        org_vel[i] = float(state[2])
        org_theta_dot[i] = float(state[3])

    plt.plot(org_theta, org_theta_dot, label = 'ang. trajectory')
    # Add arrows at specific points
    for i in range(0, len(org_theta), 20):  # Add an arrow every 20 points
        dx = org_theta[i+1] - org_theta[i]
        dy = org_theta_dot[i+1] - org_theta_dot[i]
        plt.arrow(org_theta[i], org_theta_dot[i], dx, dy,
                shape='full', lw=0, length_includes_head=True,
                head_width=0.5, head_length=0.5, color='red')
    plt.title('Direct Collocation (Hermite-Simpson)')
    plt.legend()
    plt.xlabel('angular pos.')
    plt.ylabel('angular vel.')
    plt.grid()
    plt.show()

    plt.figure()
    plt.plot(org_theta, org_theta_dot, label = "original initial state")
    plt.plot(theta, theta_dot, label = 'preturbed initial state')
    plt.xlabel('angular pos.')
    plt.ylabel('angular vel.')
    plt.grid()
    plt.title('Direct Collocation (Hermite-simpson)')
    plt.legend()
    plt.show()

    plt.figure(1)
    t = np.linspace(self.t0, self.tf, self.N)
    plt.plot(self.opt_u[0, :-1].T, label = 'control input')
    # plt.plot(inter_u, label = 'interpolated')
    plt.xlabel('time')
    plt.ylabel('amplitude')
    plt.title('Direct Collocation (Hermite-simpson)')
    plt.grid()
    plt.legend()
    plt.show()



obj = HermiteSimpsonDirectCollocation(N = 250)
states, controls, contorls_mid= obj.optimize()
obj.simulation()

# obj.simulation()

